{
  "hash": "fc617e963b699f67a9d0f6180ac56e44",
  "result": {
    "markdown": "---\ntitle: Names and Values\n---\n\n\nIn R, and in computer programming in general, the most essential operation is to assign **values** to **names**.\nBy **value**, we then simply mean a piece of information. This can be a anything: a single number, a string (i.e. piece of text), a list of numbers, and even an entire data set. \n**Assigning** such values to names is essential, because it allows us to more easily refer to the values. \n\nIn plain terms, **assignment** is how you make R remember things by assigning them to a name. To assign a value to a name, we use the **arrow notation**: `name <- value`. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\n```\n:::\n\n\n::: {.callout-note title=\"Good to know: you can also use `x = 2`\" collapse=\"true\"}\nInstead of using the **arrow** notation, you can also use the **equal sign** notation: `name = value`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 2\n```\n:::\n\n\nWe will in general always use the **arrow** notation. But if you encounter the **equal sign** notation, just remember that it's the same thing.\n:::\n\nBy **running** the code `x <- 2`, you are saying: **Assign the value `2` to the name `x`**. \nAny values that you assigned to names are stored in your **Environment**. You can see this environment in the top-right window, under the **Environment** tab.\nIf you assigned `2` to `x`, you should see a table called **Values**, with in the left column the names (`x`) and in the right column the values (`2`).\n\nFrom hereon, when you use the name `x` in your code, it will **refer** to the value `2`. So when we run the code `x * 5` (x times 5) it will print the number `10`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx * 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\n\n\n::: {.callout-note title=\"Why does R print a [1] before the result?\" collapse=\"true\"}\nWhen running `x * 5`, R correctly prints the value 10. But why does it say `[1] 10`?\nThe reason is that R always thinks of a number (or string) as a **vector** (i.e. list of values), that can have 1 or multiple values. \nThe `[1]` indicates that 10 is the first (and only) value.\n\nIf you print a longer **vector**, you can see that R prints `[...]` at the start of each line, just to help you see the position of individual values.\nThe following code generates a vector with numbers from 1 to 50\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:50\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n```\n:::\n:::\n\n:::\n\n\n## Assigning different types of values\n\nYou can assign any type of value to a name, and you can use any name, as long as it starts with a letter and doesn't contain spaces or symbols (but underscores are OK)\n\n\n::: {.cell}\n\n```{.r .cell-code}\na_number = 5\nmy_cats_name = \"Hobbes\"\n```\n:::\n\n\nIf you run this code and check you **Environment** (top-right), you should now see these name-value pairs added.\n\n\n## Assigning results \n\nTill now we only directly assigned values to names. This is convenient, but the power of assignment really shines when you use it to store **results**. \nFor example, we can also do this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 5 + 10\n```\n:::\n\n\nThis a very simple example, but just think for a second what this allows us to do. \nSince we can assign anything to a name, we can break down any complicated procedure into multiple steps! \nFor now, the key lesson is just to wrap your head around the syntax for assigning values to names. \nThis is fundamental to everything you will be doing in R (and in programming in general). \n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}